# Tools Specification

## Purpose

Defines the tool framework and each tool's behavior, inputs, outputs, and risk levels. Tools allow the assistant to interact with external services and storage.
## Requirements
### Requirement: Tool Definition

Every tool SHALL be defined with a Zod schema for input validation, a description, and an explicit risk level.

The tool framework SHALL provide a `ToolRegistry` for registering tools and converting them to AI SDK format.

The registry SHALL convert tool definitions to Vercel AI SDK `tool()` format for use with `generateText`.

#### Scenario: Tool registered with schema and risk level

- **WHEN** a new tool is registered in the ToolRegistry
- **THEN** it has a name, description, Zod input schema, an explicit risk level, and an execute function

#### Scenario: Registry converts to AI SDK format

- **WHEN** the agent prepares an LLM invocation
- **THEN** the ToolRegistry converts all registered tools to the AI SDK `tool()` format
- **AND** each tool's execute function is wrapped with risk-level gating

### Requirement: Risk Levels

The system SHALL classify tools into three risk levels:

- **`low`**: Execute immediately. The tool runs and returns its result to the LLM.
- **`medium`**: Execute immediately. The system prompt instructs the LLM to report the action in its reply.
- **`high`**: Request approval. The tool saves a pending approval to D1, sends an inline keyboard to Telegram, and returns a message to the LLM indicating approval has been requested.

#### Scenario: Low-risk tool executed immediately

- **WHEN** a tool with risk level `low` is invoked by the LLM
- **THEN** it executes immediately and returns the result

#### Scenario: Medium-risk tool executed and reported

- **WHEN** a tool with risk level `medium` is invoked by the LLM
- **THEN** it executes immediately and returns the result
- **AND** the LLM is instructed via system prompt to report the action in its reply

#### Scenario: High-risk tool requests approval

- **WHEN** a tool with risk level `high` is invoked by the LLM
- **THEN** the pending operation is saved to D1
- **AND** an inline keyboard message is sent to Telegram
- **AND** the tool returns a message to the LLM indicating approval has been requested

### Requirement: Forwarded Email Reader — Design Rationale

The system SHALL receive emails via forwarding to a dedicated Cloudflare Email Workers address, rather than accessing mailboxes directly via provider APIs.

This approach SHALL NOT require broad access permissions to the user's email provider.

The user SHALL explicitly choose what the assistant can read by forwarding specific emails. Semi-automation via email provider filter rules (auto-forward) SHOULD be supported.

#### Scenario: Email received via forwarding

- **WHEN** an email is forwarded to the dedicated Email Workers address
- **THEN** the system processes it without accessing the user's mailbox directly

### Requirement: Forwarded Email Reader — Ingestion

When an email arrives at the dedicated address (e.g., `inbox@your-domain.com`), the system SHALL:

1. Parse the MIME content using `postal-mime`.
2. Store metadata (sender, subject, date) and an LLM-generated summary in D1.
3. Store raw data (full body text and attachments) in R2.
4. Optionally send a new-email notification to Telegram.

The summary SHALL be a concise description of the email's content (enough to understand "what it's about"), generated by a single LLM call at ingestion time.

#### Scenario: Email ingested and stored

- **WHEN** an email arrives at the dedicated address
- **THEN** metadata and an LLM-generated summary are stored in D1
- **AND** the raw body and attachments are stored in R2

#### Scenario: New email notification

- **WHEN** an email arrives at the dedicated address
- **AND** notifications are enabled
- **THEN** a notification is sent to Telegram

### Requirement: Forwarded Email Reader — Tools

The system SHALL provide the following email tools:

- **`search_emails`** (risk: `low`): Keyword search over subject and summary in D1. Returns sender, subject, date, and summary.
- **`read_email`** (risk: `low`): Retrieve the full email body from R2 for a specific email.

#### Scenario: Search emails by keyword

- **WHEN** the LLM invokes `search_emails` with a keyword
- **THEN** D1 is queried for matching subjects and summaries
- **AND** results include sender, subject, date, and summary

#### Scenario: Read full email body

- **WHEN** the LLM invokes `read_email` with an email ID
- **THEN** the full email body is retrieved from R2

### Requirement: Calendar — Protocol

The system SHALL connect to iCloud CalDAV using the `tsdav` library. Authentication SHALL use an Apple ID and an app-specific password.

The system SHOULD abstract over CalDAV so that switching to another CalDAV-compatible provider (e.g., Google Calendar) is straightforward.

#### Scenario: CalDAV connection established

- **WHEN** the system initializes the calendar tool
- **THEN** it connects to iCloud CalDAV using `tsdav` with Apple ID credentials

### Requirement: Calendar — Scope Restriction

The system SHALL operate on a single dedicated calendar in iCloud (e.g., "AI Assistant Shared") only.

The system SHALL NOT have access to all events in the user's main calendar.

Returned fields SHALL be limited to title, time, and all-day flag. Participant lists and meeting notes SHALL be excluded.

#### Scenario: Only dedicated calendar accessed

- **WHEN** the system queries calendar events
- **THEN** it only accesses the designated calendar (e.g., "AI Assistant Shared")
- **AND** does not access other calendars in the account

#### Scenario: Limited fields returned

- **WHEN** calendar events are returned
- **THEN** only title, time, and all-day flag are included
- **AND** participant lists and meeting notes are excluded

### Requirement: Calendar — Tools

The system SHALL provide the following calendar tools:

- **`get_events_availability`** (risk: `low`): Returns time slots only (start, end, all-day flag) with no titles or details.
- **`get_events_details`** (risk: dynamic, see below): Returns events with titles and details.
- **`create_event`** (risk: `high`): Creates an event. Approval required.
- **`update_event`** (risk: `high`): Updates an event. Approval required.
- **`delete_event`** (risk: `high`): Deletes an event. Approval required.

#### Scenario: Availability check returns time slots only

- **WHEN** the LLM invokes `get_events_availability`
- **THEN** only time slots (start, end, all-day flag) are returned
- **AND** no titles or details are included

#### Scenario: Event mutation requires approval

- **WHEN** the LLM invokes `create_event`, `update_event`, or `delete_event`
- **THEN** the approval flow is triggered before execution

### Requirement: Calendar — Two-Axis Read Permission

The risk level of `get_events_details` SHALL be determined dynamically by two axes:

**Axis 1 — Information Granularity:**
`get_events_availability` SHALL return only time slots with no titles or details, so that availability checks ("Am I free Wednesday?") can always be answered instantly without approval.

**Axis 2 — Event Origin:**
The system SHALL record the UID (CalDAV event identifier) of every event it creates in D1. When `get_events_details` is called:

- If the event's UID exists in D1 (created by the assistant): risk is `low` (immediate access).
- If the event's UID is not in D1 (created by the user directly): risk is `high` (approval required).

#### Scenario: AI-created event accessed without approval

- **WHEN** `get_events_details` is called for an event whose UID exists in D1
- **THEN** the event details are returned immediately without approval

#### Scenario: User-created event requires approval

- **WHEN** `get_events_details` is called for an event whose UID is not in D1
- **THEN** the approval flow is triggered before returning event details

### Requirement: Calendar — Workers Compatibility

The `tsdav` library is built for Node.js. It SHOULD work under Workers' `nodejs_compat` compatibility flag. If incompatible, the system SHALL fall back to a thin wrapper that constructs CalDAV HTTP requests directly.

#### Scenario: tsdav works under nodejs_compat

- **WHEN** `tsdav` is used with the `nodejs_compat` flag enabled
- **AND** it functions correctly
- **THEN** the system uses `tsdav` directly

#### Scenario: tsdav incompatible with Workers

- **WHEN** `tsdav` fails under the Workers runtime
- **THEN** the system falls back to direct CalDAV HTTP requests

### Requirement: File Operations

The system SHALL use an R2 bucket as a sandboxed file store. There SHALL be no access to local file systems.

Path traversal SHALL be prevented by allowing only alphanumeric characters, hyphens, underscores, slashes, and dots in file keys.

The system SHALL provide the following file tools:

- **`list_files`** (risk: `low`).
- **`read_file`** (risk: `low`).
- **`write_file`** (risk: `medium`, reported).
- **`delete_file`** (risk: `high`, approval required).

#### Scenario: Path traversal prevented

- **WHEN** a file operation is requested with a key containing `../` or other invalid characters
- **THEN** the operation is rejected

#### Scenario: File listing and reading

- **WHEN** the LLM invokes `list_files` or `read_file`
- **THEN** the operation executes immediately (risk: `low`)

#### Scenario: File deletion requires approval

- **WHEN** the LLM invokes `delete_file`
- **THEN** the approval flow is triggered before execution

### Requirement: Web Search

The system SHALL provide a web search tool using the Tavily Search API that requires a single API key.

Risk level SHALL be `low`.

The tool SHALL return search result snippets AND an LLM-generated answer summary from Tavily (`include_answer: "advanced"`).

Phase 1 SHALL NOT include full-page browsing (fetching and rendering entire pages via `include_raw_content`).

#### Scenario: Web search executed

- **WHEN** the LLM invokes the web search tool with a query
- **THEN** the Tavily Search API is called
- **AND** an answer summary and up to 5 result snippets (title, URL, content) are returned immediately (risk: `low`)

#### Scenario: Answer summary included

- **WHEN** a web search is performed
- **THEN** the response includes an LLM-generated answer summary from Tavily
- **AND** the answer is generated in "advanced" mode for detailed responses

#### Scenario: No full-page browsing

- **WHEN** a web search is performed
- **THEN** only search result snippets and an answer summary are returned
- **AND** full-page content is not fetched or rendered

